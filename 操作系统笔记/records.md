# 操作系统高频面试问题

1. 线程和进程的关系
> 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。
资源分配给进程，同一进程的所有线程共享该进程的所有资源。
线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。
处理机分给线程，即真正在处理机上运行的是线程。
线程是指进程内的一个执行单元，也是进程内的可调度实体。

2. 线程和进程的区别
> （1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。
（2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。
（3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。
（4）系统开销：在创建或撤销进程的时候，由于系统都要为之分配和回收资源，导致系统的明显大于创建或撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式下不会对其他的进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但是在进程切换时，耗费的资源较大，效率要差些。
（5）线程的划分尺度小于进程，使得多线程程序的并发性高。
另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大的提高了程序运行效率。
（6）线程在执行过程中，每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，有应用程序提供多个线程执行控制。

3. 一个进程可以创建多少线程，和什么有关
>在32位Linux下，理论上，一个进程可用虚拟空间是3G，默认情况下，线程的栈的大小是10MB，所以理论上最多只能创建300多个线程。如果要创建多于300的话，必须修改编译器的设置。
一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定，只要虚拟空间足够，那么新线程的建立就会成功。如果需要创建超过300以上的线程，减小你线程栈的大小就可以实现了。

4. 一个程序从开始运行到结束的完整过程（四个过程）
>操作系统在创建进程后，把控制权交到程序的入口，这个入口往往是运行库中的某个入口函数
入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量的构造
入口函数在完成初始化后，调用main函数，正式开始执行程序主体部分
main函数执行完毕后，返回到入口函数，入口函数进行清理工作，包括全局变量析构、堆销毁、关闭I/O等，然后系统调用结束进程

>预处理(Prepression)
编译(Compilation)
汇编(Assembly)
链接(Linking)

5. 进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）
> 同步进程通信：管道、FIFO（命名管道）、消息队列、共享内存、信号量（用于进程同步）、socket套接字
异步进程通信：信号

>线程互斥和同步的方法
互斥：互斥量、读写锁、自旋锁
同步：轮询结合互斥量、条件变量、信号量、屏障

6. 文件读写使用的系统调用

7. 进程间的通信的几种方式
>管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；

>信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；

> 消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；

> 共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；

> 信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；

> 套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

8. 线程同步的方式
* 互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
* 信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
* 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

9. 什么是死锁？死锁产生的条件？
>死锁的概念
在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。

>死锁产生的四个必要条件
互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；
占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；
非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放
循环等待：若干进程之间形成一种头尾相接的环形等待资源关系

9. 死锁的处理基本策略和常用方法
解决死锁的基本方法主要有 预防死锁、避免死锁、检测死锁、解除死锁 、鸵鸟策略 等

10. 进程有哪几种状态？
就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；
运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数；
阻塞状态： 进程等待某种条件，在条件满足之前无法执行；

11. 线程有几种状态？
在 Java虚拟机 中，线程从最初的创建到最终的消亡，要经历若干个状态：创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。在给定的时间点上，一个线程只能处于一种状态。

12. 守护进程、僵尸进程和孤儿进程
> 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程所收养，并由init进程对它们完成状态收集工作。
